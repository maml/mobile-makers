Section 0 - Introduction

0.1 What is the intended purpose and potential advantage of learning object oriented design?

It is about how to build better and more complex applications. It's also about how to
understand what you need to do and how to get your code written faster with less pain,
less bugs, and more flexibility.

0.2 Why might it be advantageous to analyze and design before beginning programming?

If one attempts to write a program without understanding what problem it is that the 
program is trying to solve (analysis) and not have a plan for how to go about solving
it (design), there's little chance of success and a greater chance of producing rigid,
error-prone, and incoherent code.

0.3 What is the difference between a "waterfall" and an "agile" approach to development?

"Waterfall" development steps through each phase of the cycle: analysis, design,
implementation, installation, maintenance, and doesn't look back. Once you and/or your
team complete one phase it's on to the next. It takes months to deliver working software.

"Agile" development supports a notion of continual development. This continual development
is accomplished through iterations. Instead of moving sequentially through each phase of
the cycle and not looking back, the team completes the cycle several times. The software is improved
incrementally, one or two features at a time, upon completion of each iteration. Working
software can be delivered within days.

What is an iteration and how do we to use them to build software?

An iteration may be described as a short, most likely one to two week period, where a
team analyizes, designs, builds, tests, and delivers a small set of features.

Section 1 - Core Concepts

1.1 What are the various types of programming languages and in which domain is each used?

Procedural C, C++, BASIC
Logic      Prolog
Functional Haskell
OO         Java, Ruby, Objective-C

OO languauges are the languages of choice in the modern web/app development landscape.
Functional and Logic langauges are most likely to be found in university, academic, or
other specialized environments.

1.2 Describe in your own words the three properties of a computing object.

The three properties are: identity, attributes, and behaviors. An object's identity is that
which gives it its 'is'-ness. An object's attributes are that which describe a given state.
An object's behaviors are those actions of which it may partake.

1.3 Explain how classes are analogous to blueprints. Include the relationship between a
class and an object. Can you think of how the analogy breaks down?

Classes are like blueprints in that they contain all the necessary information to
instantiate an object, just like a blueprint contains all the necessary information to
build a house. The analogy breaks down in that blueprints describe physical objects
intended to exist in the real world where classes will often be describing non-physical
concepts or ideas.

1.4 When a developer uses the term "abstraction" what are they describing?

They are describing an idea or concept that's compeletely separate from any instance.

1.5 What does encapsulation prevent? What does it enable?

Encapsulation prevents dependencies across the different parts of an application. In the
future if changes need to be made, they will be much easier if you only have to make
the change in one place.

1.6 Describe the inheritance relationship between classes. When would this relationship
be advantageous to establish?

A class may be based upon another already existing class, that is, it has bestowed upon
it all the properties of its parent class: its identity, its attributes, and its behaviors.

If you notice you're about to create a class that's almost exactly like an already existing
class, you may want to consider having it inherit from the already existing class.

1.7 What is the basic idea behind polymorphism? How can it make the classes
we create more flexible?

Polymorphism allows us to be confident that engaging in a certain behavior results in
the desired outcome, even if that behavior is happening in different contexts.

It can make classes more flexible by allowing them to do the right thing at the
right time. For example a subclass may override a particular method of its superclass;
other sublcasses don't have to do that, they can if they want to, but it's not a
requirement.

Section 2 - Object-Oriented Analysis and Design

2.1 What are the steps of analysis that come before writing code for an application?
Why do you think these steps make writing the code easier?

There are five steps:
1 Gather requirements
2 Describe the app
3 Identify the main objects
4 Describe the interactions
5 Create a class diagram

Following the five steps results in a class diagram which tells you what you should
be coding and, having gone through the analysis process, understand why you're
coding it.

2.2 What should you have after you've completed the first phase of defining
your requirements?

Some sort of document that lists out the things the app MUST do.

2.3 What is UML? Why Is it useful to visualize your application before coding it?

UML stands for Unified Modeling Language. It can help clarify the relationships
between the objects of the app and provide details of what those objects are
intended to be.
